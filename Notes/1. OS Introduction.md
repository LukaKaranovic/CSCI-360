# Operating System Basics
### Examples of operating systems:
- Unix, FreeBSD (UC Berkeley Unix)
- Minix, Mach, L4
- Linux
- Mac OS X
- Windows
- Android
- iOS

### Operating System in a Computer System
![[opsystemcompsystem.png]]
- Users interact with systems and application programs/software, then the operating system (also a software) **manages** these applications and **tells the hardware what to do.**

An OS is a **system software** that acts as an **intermediary/link** between the application software and computer hardware.
- It **executes** application software.
- It provides **system level services** to the application software (convenience to the application software developers)
- It controls and enables **efficient usage** of **system hardware.**

# Operating System Roles
The OS has two important roles:
1. Provides a **nice abstraction** around the hardware, known as "**extending the machine.**"
	- An OS is called an extended machine because it extends the capabilities of the underlying hardware by **creating a layer of abstraction** over the complex, low-level operations.
2. Manages the hardware **resources.**
	- The OS manages hardware resources such as the **CPU, memory, storage, and I/O devices**
		- Process management and scheduling - CPU
		- Memory management - Memory
		- File systems - Storage
		- Device Drivers/Management - I/O Devices
	- It manages resources using either time or space **multiplexing**.

## Extended Machine
 An OS is called an extended machine because it extends the capabilities of the underlying hardware by **creating a layer of abstraction** over the complex, low-level operations.

- Computer architecture at the low level is **primitive** and **awkward** to program.
- Application programmers do not want to get too involved at the low level.
- Application programmers want simple and **high-level abstraction** of the architecture to deal with.

**OS hides the complex hardware and presents nice, clean, elegant, consistent abstractions to work with**

## Resource Manager
- Provides **orderly** and **controlled allocation of resources**
	- Keeps track of which programs are using which resources
	- Grants resource requests and accounts resource usage.
	- Mediates conflict resource requests.
- Since multiple processes need the same resources, the OS **multiplexes/shares resources** among them. 
	- Time and space **multiplexing**.

#### Definitions
>A **resource** is anything the **system provides** that processes (programs in execution) **need** in order to run.
>	Ex. CPU provides **processor time**. Memory provides **RAM**. I/O devices provide their **functionalities**.
>
>**Time multiplexing** - Single resource is used by multiple processes **one a time**, with each process getting a **time slice.**
>	Ex. CPU Scheduling
>**Space multiplexing** - Single resource is divided into **different parts** and assigned to multiple processes **at the same time.**
>	Ex. Memory allocation

# Operating System Components
The OS consists of many components and each component performs specific tasks.
![[oscomponents.png]]
The ones this course will be looking at:
- Process Management System
	- Scheduler, Dispatcher, and Inter Process Communication
- Memory Management System
- File System
- I/O System

### Components vs. Modules
A **component** is a **logical part of a system** that provides a specific function or set of related functions.
- It is usually defined in terms of its **role and responsibilities** in the overall system.
- Components tend to be **higher-level abstractions** than modules, focusing on _what_ they do rather than _how_ they are implemented.
Ex.
- The **file system** component handles file storage, naming, and retrieval.
- The **memory management** component handles allocation and protection.

A **module** is a **self-contained piece of code** (or implementation unit) that performs part of the system’s functionality.
- It usually has **well-defined interfaces** (functions, classes, APIs) and **internal encapsulation** of data/logic.
- Modules are more about _how_ the functionality is implemented.
Ex.
- The file system component may have modules like the **directory module**, the **block allocation module**, and the **file access module**.
- The memory management component may have modules for **paging**, **segmentation**, and **virtual memory management**.

# Dual-modes: User and Kernel Modes
**Dual-modes** (**user mode** and **kernel mode**) operation allows the OS to protect itself and other system components.
- The **OS** runs in **kernel mode**, it has complete access to all the hardware and can execute **all** instructions, including **privileged** ones.
- **Other programs** run in **user mode**, they cannot access the hardware directly and cannot run **privileged** instructions.
![[dualmodes.png]]

## Kernel vs. Kernel Mode
The **kernel** is the *core part of the OS*.
- The main code of the OS
- Manages critical tasks
	- process scheduling
	- memory management
	- device I/O
	- file systems
	- system calls

**Kernel mode** is a CPU execution mode with full privileges:
- The code has full access to all hardware and memory
- All CPU instructions are available
- Kernel runs in this mode, but user programs normally do not.

# System Calls
**Programs** in **user mode** can **indirectly** access hardware resources and execute **privileged** instructions through **system calls**.

A **system call** changes mode to **kernel**, provides **system level service** by executing kernel routine, and resets mode to **user** at return.

The **mode bit**, provided by hardware, gives the ability to distinguish when system is running user mode code or kernel mode code.
- 0 for kernel mode
- 1 for user mode
- Can't flip the mode bit in user mode.

![[syscalldiagram.png]]
#### Explanation
- A user application called `size_t count = read(fd, &buffer, size);`
- File is already open, have the correct **file descriptor (fd).** Now application is calling the 'read' system call with a buffer (location of data), size (amount of bytes we want to read).
	- The return value is how many bytes you read.
- All the system call parameters are put onto the stack (or registers. Old program counter (PC) is put on stack.
- The 'read' function is split into two routines (one user space and one kernel space)
- The **system call user space routine** puts the system call # in a register so it can figure out what system call to execute later.
	- It calls a **trap** (an interrupt but by software), which invokes the trap handler.
		- Trap gets the hardware to flip the mode bit and call the trap handler
- Trap handler routine calls the **system call dispatcher** that is in OS. 
- The **system call dispatcher** function needs to retrieve system call # from the register that it was saved to in the **user space routine**.
	- The **system call #** determines what function the OS will call to do the action.
- The **system call #** in this case means the OS has to call the **read service routine**. 
- The OS executes the actions for this routine, retrieves parameter information from the stack, does the read action, and returns to the **syscall kernel space routine** (or system call dispatcher).
- This returns to the trap handler, which returns to the hardware through **IRET**.
	- IRET stands for **return from interrupt**
	- IRET can't be called by any user program.
- The hardware flips mode bit back to user mode and returns back to the **system call user routine**.
- Then that user routine returns back to the user program where the function was called.

The path: **user app → syscall stub → trap → kernel handler → syscall dispatch → service routine → back to user**.

### Examples of system calls
**These examples are in Unix/Linux:**

File management system calls:
![[filemgmtsyscall.png]]

Directory and file system management system calls:
![[dirfilemgmtsyscall.png]]

Process management system calls:
![[procmgmtsyscall.png]]

Miscellaneous system calls:
![[miscsyscall.png]]

# Operating System Architecture
The OS architecture is a way to **organize** OS **components**.

Two dominating architectures:
1. Monolithic
2. Microkernels

## Monolithic
A **monolithic kernel** is an operating system architecture with the **entire operating system running in kernel space.**
- A set of primitives or system calls implement all operating system services such as process management, concurrency, and memory management.
- Whole kernel is compiled into one large binary file

Kernel consists of a **main procedure**, a set of **service procedures** and a set of **utility procedures**.
- **Starts** with the **main procedure** that invokes the requested service procedure.
- **Service procedures** carry out the **system calls**.
- **Utility procedures help service procedures** and are called by service procedures.
- *Most services run within the kernel.*
![[monolithicdiag.png]]
- Diagram of a monolithic kernel, all in one executable

**Pros:**
- Simplicity of design and ease of implementation 
	- It is simpler to manage because one process manages everything
- Performance (speed)
	- Since everything runs in kernel mode and system calls are direct, there's little overhead from switching between components.
**Cons:**
- Poor maintainability
	- All kernel code lives in one large binary -> hard to isolate or update parts without affecting the rest.
	- Debugging is difficult because bugs can propagate across subsystems.
	- Harder to add new features or device drivers because it requires modifying/recompiling the kernel, which can be complex since it is so big.
- Security risks
	- A bad driver or piece of code can crash the entire system or open security holes.

## Microkernels
A **microkernel** is an operating system architecture where the kernel (the core part of the OS) contains only the **minimal, most essential functions**. 
- Examples of essential functions:
	- **Low-level address space management** (memory protection, virtual memory basics).
	- **Thread/process management** (scheduling, context switching).
	- **Inter-process communication (IPC)** → message-passing between services.
- Everything else (like device drivers, file systems, network stacks) runs in **user space**, outside the kernel.
	- Have to relax restrictions: some of the user mode services can access specific resources (as opposed to only kernel mode)
		- Ex. network driver can't access disk, disk driver can't access network
	- everything still has to ask kernel for permission (IPC)
- *Most services run outside of the kernel*.
![[microkernelsdiag.png]]
**Pros:**
- Fault Isolation
	- Only the minimal core runs in kernel mode and device drivers, file systems, etc. run in user space.
	- If a driver or service crashes, the whole system usually keeps running.
- Security
	- Most services are isolated in user space, so they have fewer privileges.
	- One service being compromised doesn't necessarily give full control of the OS.
- Modularity / Maintainability
	- Easier to update, replace, or debug individual services without touching/recompiling the kernel core.
- Extensibility
	- New services can be added in user space without needing to modify the kernel. Good for things that need custom components
**Cons:**
- Performance
	- Communication between services requires **inter-process communication (IPC)**, which is slower than direct function calls
	- Multiple **context switches** between user space and kernel space can add latency.
- Complex Design / Implementation
	- More moving parts -> higher initial development cost compared to a monolithic kernel
