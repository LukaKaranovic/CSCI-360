# File Abstraction
File abstraction results from the **essential requirements** for **long-term information storage**
- Long-term information storage is the main use of a file

Requirements:
1. System needs to **store** a very large amount of **information**
2. Stored information must **survive termination** of process that was using it
3. If approved, multiple processes must be able to **access** the stored information **concurrently**

A **disk** is a **linear sequence** of fixed-size sectors or **blocks**.
Disks support two operations:
- **Read** block k
- **Write** block k
![[Pasted image 20251020140300.png]]
- An early method for addressing physical data blocks was using cylinder head sector (CHS) to map them.
	- Cylinder refers to which specific disk
	- Head refers to read/write arm (which is used)
	- Sector refers to specific segment on a track where data is stored.
- A sector is a physical unit on the disk, block is a logical unit and is in terms of whole sectors (since we can't read/write less than 1 sector)

Information of a **file** may need one or more disk blocks.
- System **allocates** free disk blocks to a file and **keeps track** of this allocation.

## File Structure
Information may be structured inside a file in different ways.
![[Pasted image 20251020140945.png]]
- Byte Sequence - Organized as a collection of bytes.
- Record Sequence - Records are stored in the order they were written in. Records can be fixed or variable length.
- Tree Sequence - Organized in hierarchical manner for rapid searching (each record holds a key)

## File Types
Several types of files (denoted by extension). Different file types store information in different formats and are used for different purposes.
![[Pasted image 20251020141103.png]]
- Any file with a **structure** is a **binary** file
- Files without a structure are ASCII files

## Name
- Files are **identified** by their **names**
- Each file has a **unique** file name
- File names also have **file extensions** that indicate their types

## Attributes
System maintains **metadata** or **attributes** about each file.
- These attributes are used by the system to **manage** all the files in the system.
![[Pasted image 20251020141621.png]]

## File Operations
System permits many **operations** on a **file**

Examples of common file operations (**bold** aren't in every OS):
1. Create - create a new file
2. Delete - delete a file
3. Open - open a file (if you have permission)
4. Close - close a file (if it is open)
5. Read - read data from an open file (wherever read pointer is)
6. Write - store data to an open file (wherever write pointer is)
7. Append - store data to the end of a file
8. Seek - reposition file's internal read/write pointer to a specific location
	- OS normally maintains read/write pointer
9. Get attributes - get read/write/execute permissions for the file
10. Set attributes - set read/write/execute permissions for the file
	- `chmod` command calls this
11. Rename - change a file's name
12. **Link** - creates a new name to an existing file
	- number of different names for a file = **link count**
	- deleting a link won't delete the file's content, just the name, but will **decrement** link count.
		- if **link count is 0**, file's content will be deleted if the file is not open
13. **Unlink** - removes a link from a file
	- decrements the link count of a file
		- if **link count is 0**, file's content will be deleted if the file is not open

#### Example program using file system calls
Simple program that **copies** a file:
```c
	#define TRUE 1
	#define BUF_SIZE 40960
	#define OUTPUT_MODE 0700
	
	int main(int argc, char** argv) {
		int in_fd, out_fd, rd_count, wt_count;
		char buffer[BUF_SIZE];
		if(argc != 3) exit(1);
		in_fd = open(argv[1], O_RDONLY);
		if(in_fd < 0) exit(2);
		out_fd = creat(argv[2], OUTPUT_MODE);
		if(out_fd < 0) exit(3);
		while(TRUE) { // break out of loop when nothing left to read
			rd_count = read(in_fd, buffer, BUF_SIZE);
			if(rd_count <= 0) break;
			wt_count = write(out_fd, buffer, rd_count);
			if(wt_count <= 0) exit(4);
		}
		close(in_fd);
		close(out_fd);
	}
```
- Never leave your files open
- file descriptor (fd), return from `open()`, is an index in a **global file table** that **contains all opened files.**
	- This index can be used to search file table to get file metadata
	- Using `close()` on a file removes that file descriptor from the open file table
		- if you forget to close a file, the file information will still be in the file table, taking up space (file table has a capacity)

# Directory Abstraction
Systems use **directories**/**folders** to **organize** hundreds of files in a file system.
- Files are **stored** inside a directory.
- A **directory** may contain one or more **subdirectories**
- Each directory name uniquely identifies a directory or subdirectory

## Directory Entries
The **contents of a directory**, such as files, and subdirectories, are commonly referred to as **directory entries**.
- A directory entry holds the **name** and the **attributes** of a file or subdirectory
- **Disk blocks allocated** to a file or a subdirectory are one of its **attributes**

![[Pasted image 20251022133814.png]]
**a)** A directory where each entry contains the name and attributes
**b)** A directory where each entry contains the name and refers to a data structure, which contains the name and attributes

## Directory Systems
A **single-level** directory system is where there is only one level of directories below the root directory `/`
![[single-level_directory.png]]

A **hierarchical** directory system is where there are several levels of subdirectories below the root directory.
![[hierarchical_directory.png]]


## Directory Operations
System **permits** many **operations** on a **directory**, here are some:
1. Create - create a new directory
2. Delete - delete an existing directory
3. Opendir - open an existing directory
4. Readdir - read an existing directory
	- in OS, command like `cd` lists every entry
	- in a program, reads a directory entry by entry
5. Rename - change the name of an existing directory
6. Closedir - close an open directory

# File System Disk Layout
**First disk block** is the **Master Boot Record (MBR)**, which contains the code that is executed when the computer starts

![[disk_partitions.png]]
A disk is **partitioned** into several partitions to **hold multiple operating systems** on the **same disk**; one in each partition and **only one partition is active at a time.**
- A **partition table** is kept after MBR on the disk. 
	- It keeps track of the **starting addresses** of all the **partitions** and which partition is the **active partition**
- MBR code reads the partition table and **locates the active partition,** then **reads the first block**, called **boot block,** of the **active partition** and **executes** it.
	- Boot block code **loads the operating system, including filesystem**, from the partition into the **memory**

#### Filesystem information consists of:
- **boot block** - code that **loads the OS, including filesystem**, from the partition into the **memory**
- a **superblock** (filesystemâ€™s metadata, e.g., filesystem type, number of blocks etc.)
- **free-block information** - where are the free blocks in the disk?
	- consult this when creating new files, directories, etc.
- **allocated-block information**
	- i-nodes
- **root directory information** - kept in a fixed location
- the **other directories and file information**

![[Pasted image 20251022135544.png]]
- Example of a file system layout

# Disk Block Allocation
How do we allocate disk blocks to a file?

## Contiguous
![[Pasted image 20251022140447.png]]
- Not used, because of an external-fragmentation-like problem.

## Non-contiguous
![[Pasted image 20251022140500.png]]
- Used in many OSs

# MS-DOS File System (FAT)
![[Pasted image 20251022140724.png]]
- A directory entry, which contains the **disk addresses and attributes**
- Time and date is when it was last modified

Uses a **file allocation table (FAT)**
![[Pasted image 20251022140816.png]]
- Has an **entry** for each **physical disk block** (indexed by block number)
	- **Directory entry** tells you where a file's **first block** is, then the FAT will tell you where the next block is.
		- Ex. directory entry for file A says its first block is disk block 4, FAT at 4 says the next block is at 7, etc. until it reaches -1 (end of file)
- Blocks without an entry are **free blocks**

![[Pasted image 20251022141504.png]]
- Breakdown of a partition in a MS-DOS filesystem.

# UNIX V7 File System (I-Node)
UNIX V7 directory entries contain only the file name and a pointer to an **i-node**.
- There is one i-node per directory entry (file or subdirectory)
- An **i-node** contains the disk addresses and file attributes
- The first 10 disk block addresses are directly kept in the i-node
- i-node also contains the addresses of single, double, and triple indirect disk block addresses 
	- Basically a pointer to another i-node if more disk blocks are needed for that file.
![[i-node_diagram.png]]

A disk partition in Unix V7 file system:
![[unix_v7_partition.png]]
- **Data block bitmap** keeps track of **free disk blocks**
- **I-node bitmap** keeps track of **free i-nodes**
- **I-node table** contains **i-nodes** that keep track of **disk block allocation**
- **Root directory** uses a **fixed i-node**

## I-Node Attributes
- File Size
- Creation Time
- Last Access Time
- Last Modified Time
- Owner
- Group
- Protection
- Link Count

## Adding a File in Unix
1. Get the **disk blocks** for the file from the pool of free disk blocks.
2. Get a free **i-node** for the file from the pool of free i-nodes
3. Record the disk blocks **into i-node** and set the **link count to 1**
4. Add a **directory entry** for the file in its directory.

## Removing a File in Unix
1. Remove the **directory entry** of the file from its directory
2. **Decrement** link count
3. **Release i-node** to the pool of free i-nodes **if link count reaches zero**
4. Return all **disk blocks** to the pool of free disk blocks

## Unix Shared Files
![[shared_file.png]]
- File system containing a **shared file**
	- User B shares user C's file

Steps to add a shared file:
1. Get the **i-node** of the **original** file
2. **Increment** the link count
3. Add a **directory entry** for the shared file in its directory
4. Add the **i-node number** of the **original** file in the new directory entry of the shared file

Steps to remove a shared file:
1. Remove **directory entry** of shared file from its directory
2. **Decrement** the link count **in i-node** of the original file.
3. If link count becomes zero:
	- release the **i-node** to the pool of free i-nodes
	- return all **disk blocks** to the pool of free disk blocks

![[shared_file_operations.png]]

## File Lookup
The steps in looking up `/usr/ast/mbox` using directory entries and i-nodes starting from the root directory (assuming i-node 1 is being used for root directory)
![[unix_file_lookup.png]]

# Keeping Track of Free Blocks
We need to keep track of free blocks because we need to know where to put new files.

![[Pasted image 20251029130256.png]]
- Can store it on a linked list or bitmap

To **enhance performance** of free block list 
- **One block** of free block list is **kept in memory** 
- When disk blocks are needed that are **taken** from the **in memory list.**
- If **in memory free block list becomes empty** a **new disk block** of free block list is **brought into memory**. 
- When disks blocks are **freed**, they are **added** to the **in memory list.** 
- If the **in memory list** becomes **full** it is **written back to disk.**

![[Pasted image 20251029130701.png]]
- Alternative solution is to write half of the list to disk and keep half of it in memory when the list becomes full.

## File System Consistency
Two kind of consistency checks:
1. Block consistency
- Are allocated blocks accurately reflected in i-nodes?
	- A block must not be allocated to two files
- Are free blocks accurately reflected?
	- An unallocated block must be considered free
2. File consistency
- Link counts should be accurate (to actual directory entries)

### Block Consistency
In block consistency check, each block is **accounted** for **how many times it is in use by the files** and **how many times it is in free block list**

Example:
![[Pasted image 20251029131725.png]]
- If block in use entry for a block is 1, the free block entry for that block should be 0
- If block in use entry for a block is 0, the free block entry for that block should be 1
- Any values greater than 1 are wrong, or if entries for a block are both 0 or both 1.
	- In case of both 0s, "block in use" set to 0, "free block" set to 1
	- In case of both 1s, "block in use" set to 1, "free block" set to 0
		- Remove entry from free disk block database
	- In case of "free block" greater than 1 (n)
		- Set "free block" to 1
		- Remove n-1 entries from free disk block database
	- In case of "block in use" greater than 1
		- Set "block in use" to 0
		- Find all inodes pointing to block and get rid of all of them.
		- Set "free block" to 1

### File Consistency
1. Check all the directories starting from the root directory. 
2. Count the presence of each i-node in the directory entries of the whole file system. 
3. Compare the presence count against the link count of each i-node. 
4. If the link count is higher or lower set it to the presence count
	- If presence count is 0, and link count > 0, delete the file (happens when link count is set to 0)

## File System Caching
A **set of disk blocks are kept in memory** in order to **reduce** the number of **disk accesses.** 

Against any **read request,** the **cache blocks** are **checked first.** 
- If the block is in the cache, the request is handled without a disk access. 
- If the block is not in the cache, it is brought into the cache first and then the request is handled from the cache.

### File System Cache Lookup

![[Pasted image 20251029134231.png]]
1. **Hash the device and disk addresses** and lookup into hash table to find a disk block in the cache. 
2. All the blocks with the **same** hash value are **chained together on a linked list**
3. Additionally, all cache blocks are connected on a **bidirectional linked list** (used in LRU replacement algorithm)

#### Cache Replacement: LRU
In addition to the collision chains starting from hash table, there is an **additional bidirectional list** running through all the cache blocks. 
- The **least recently used** block is at the **front** of this list and the **most recently used** block is at the **end**. 

When a block is **referenced**, it can be **removed** from its position on the **bidirectional list** and **put at the end.**

**Cache** from the **block** at the **front** of the list is **reclaimed** when necessary. 

Some blocks are **rarely referenced two times** within a short interval. That leads to a **modified LRU scheme**:
- Modified LRU scheme takes **two factors** into account: 
	1. Is the block likely to be **needed again soon?** 
	2. Is the block **essential to the consistency** of the file system?

##### Modified LRU - Blocks
Blocks are **classified** into the following **classes** (level of importance):
- I-node
- Indirect
- Directory
	- The three above are blocks that are **necessary** for **file system consistency**
	- If they have been modified, **write them to disk immediately** irrespective of their position in the list.
- Full data 
	- block that will **not be needed soon**
	- goes to the **front** of the list and its cache will be **reclaimed** soon whenever necessary
- Partially full data
	- block that will **be needed soon**
	- goes to the **rear** of the list and its cache will **not be reclaimed** soon

This is checked periodically, not whenever a cache block is changed/filled
## Reducing Disk Arm Motion
![[reduce_disk_arm_motion.png]]
- arm movement is slower than disk spinning, which is why we prefer the right side (grouping by cylinder)
- on the left, i-node is placed at the start of the disk so it can be accessed quickly. on the right, this isn't the case, but the difference in time is way less than arm movement
