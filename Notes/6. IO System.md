# I/O Devices
There are 2 main types of I/O devices:
1. **Block devices** - hard disk, blue-ray disk, USB stick
2. **Character devices** - printer, network interface card, and mouse

## Block Devices
Stores information in **fixed-size blocks**, each one with its own **address**

**Transfers** are in units of **entire blocks**
- Allows to **read** or **write** each block independently

## Character Devices
**Transfers** a **stream of characters**, without regard to block structure
- **Not addressable**, does not have any *seek* operation

## Data Rates
I/O devices come with a **fixed** data rate
![[device_data_rates.png]]
- May be outdated, don't need to memorize. Just know that devices have fixed data rates

# Device Controllers
Device controls **connect devices** to systems.
![[device_controller_diagram.png]]
- System never talks to device directly, it talks to the device controller
	- Device Controllers may have their own processor, cache, etc. they are all different
		- but they do control the device and the system talks to it

Each Device Controller has **control registers**:
- System can **write control commands** to the device using control registers. 
- **Control registers or status registers** can be **read** to know the **status** of the device. 
- Some devices may have **data buffer** in addition to control registers. 
- **Control registers and data buffer** can be addressed in two ways: 
	- Using port numbers 
	- Mapping to memory addresses.

## Port Mapped I/O
**Controller registers** are **assigned** 8 or 16-bit **port numbers** to address. 

**I/O port space** is **separate** from memory address space. 

System access I/O ports by using **special I/O instructions**:
- `IN reg <port_number>`
- `OUT <port_number> reg`

## Memory Mapped I/O
Each **control register** is **mapped** to a unique **memory address** to which no memory is assigned.
![[memory_io.png]]
- idea is less instructions passed to processor at the expense at a bit of RAM
- a) is most common, c) is very uncommon

## Programmed I/O
Programmed I/O is **synchronous** or **blocking**
- CPU is busy with I/O operation until the I/O transfer is complete
- This can be a problem because you block other processes until the device driver is done, but you may spend some time waiting for I/O device while carrying out instruction
	- **Waste of CPU resources**

### Diagram Example
![[programmed_io.png]]

### Code Example
Writing a string to the printer using programmed I/O:
```c
	print_driver(buffer, p, count) { 
		copy_from_user(buffer, p, count); // p is the kernel buffer 
		for(i=0; i < count; i++) { // loop for 'count' characters
			while(*printer_status_reg != READY); // loop/wait until ready
			*printer_data_reg = p[i]; // output 1 character
		}
		return_to_user();
	}
```
- **Print Device Driver** code that was invoked through a **system call**
	- Does the entire job and blocks other processes from being scheduled (constantly watching over)

## Interrupt Driven I/O
Interrupt driven I/O is **asynchronous** or **non-blocking**.
 - CPU **proceeds with other jobs until interrupted** by the device controller or interrupt controller

### Code Examples
```c
	print_driver(buffer, p, count) {
		copy_from_user(buffer, p, count); // p is the kernel buffer
		i = 0; // initialize print count
		enable_interrupts();
		while(*printer_status_reg != READY); // loop until ready
		*printer_data_register = p[i++]; // output first character and
		// increment print count
		scheduler();
	}
```
1. **Print Device Driver** code, invoked through **system call**
	- Initiates the job (only does wait/while loop once)
		- Programmed I/O does wait loop for each character in for loop
	- After initiation, enforces going back to scheduler with `scheduler()` call
```c
	print_interrupt_service() {
		if (count == 0) {
			unblock_user();
		} else {
			*printer_data_reg = p[i++]; // output one character and increment print count
			count--; // decrement remaining character count
		}
		acknowledge_interrupt();
		return_from_interrupt(); // IRET
	
	}
```
2. **Print Interrupt Service** code, invoked through **device interrupt**
	- User is blocked, so interrupt handler has the responsibility of unblocking the user

![[Pasted image 20251117130202.png]]

### Interrupt-Driven Disk I/O
![[Pasted image 20251117133404.png]]
1. System **writes** a read command on **disk controller**
2. Disk controller
	- **Reads the data block** from the drive serially, bit by bit, until the entire block is in the **controller's internal buffer.**
	- **Computes** the checksum to verify that no read errors have occured.
	- **Asserts an interrupt** to the CPU to transfer the data from the buffer.
3. **Disk Interrupt Service** transfers the data **byte by byte** from the **controller buffer to the memory**.
![[Pasted image 20251117133601.png]]

# Direct Memory Access
- Getting I/O data one byte at a time **wastes CPU time.**
	- **Using Direct Memory Access (DMA)**, CPU time waste is avoided.
- System needs a **DMA Controller,** which has direct access to the system bus so it can **transfer data from I/O buffer to memory without involving CPU.**
- DMA Controllers come with control registers, memory address registers, and a byte count register.

Interrupt-Driven vs. DMA:
- In interrupt-driven disk I/O, the interrupt handler is writing from disk controller buffer to main memory.
- With DMA disk I/O, the DMA transfers data from disk controller buffer to memory without CPU involvement

## Disk I/O with DMA
![[Pasted image 20251117135057.png]]
- System **instructs DMA controller** by setting the **source** (disk controller buffer) and **destination** (memory buffer) and the **byte count.** 
	- This metadata is given by CPU. CPU tells DMA to use this metadata on next DMA request.
- System also **instructs the disk controller** to **read** a block of data **from the disk.** 
- The **disk controller reads** the whole block into its **internal buffer** and **asserts a DMA request** to DMA controller.
- DMA Controller requests for the **system bus access.**
	- It transfers the block of data from controller to main memory.
- DMA controller **completes direct data transfer** from disk controller buffer to memory after acquiring the system bus access. 
- Once the transfer is complete, DMA controller **asserts DMA acknowledgement** to the **disk controller** and **interrupt** to the system. 
- System (Interrupt Service Routine) asserts interrupt acknowledgement to DMA controller and unblocks the user process that was waiting for the I/O to complete

# Interrupt Controller
- Most of the systems come with a single Interrupt Request line and a single Interrupt Acknowledgement line. 
- A centralized Interrupt Controller is often used to **get interrupts from multiple I/O devices.** 
- An Interrupt Controller comes with **multiple** Interrupt Request lines to connect with **multiple** I/O devices. 
- An Interrupt Controller comes with an **Interrupt Priority Resolver** to resolve **priority** of the interrupts from multiple I/O devices. 
- The interrupt from the highest priority device is asserted through the system **Interrupt Request line.**
![[Pasted image 20251124130602.png]]
- IRR - Interrupt Request Register
	- multiple IRR can be set at once
- ISR - Interrupt Service Request
	- flag that says this interrupt is currently getting service
	- can have more than one if a higher priority interrupt comes in and preempts the current one


- System **asserts the first Interrupt Acknowledgement** to Interrupt Controller to inform the **acceptance** of the interrupt. 
- System asserts the **second Interrupt Acknowledgement** to the Interrupt Controller and **waits for the Interrupt Vector** corresponding to the requesting device.
- Interrupt Controller **asserts the Interrupt Vector** to the system through the data lines. 
- When given the vector (and getting second acknowledgement), system invokes the **Interrupt Service Routine** corresponding to the **interrupt vector.** 
- System asserts **End of Interrupt** to the **Interrupt Controller** at the **completion** of interrupt service routine.

![[Pasted image 20251124131954.png]]

# Goals of I/O Software
**Device independence** 
- Similar methods to access different types of devices of same type.
	- Use common conventions
	- Good for users
**Uniform naming** 
- Similar naming scheme for different types of devices.
	- Good for users
**Error handling** 
- Lower layers must handle and conceal as many errors as possible from the upper layer
	- I/O operation is the most error prone
	- If can't handle it, give a good error message to user
**I/O operations**
- Supports synchronous (blocking) or asynchronous (interrupt driven) I/O operations. 
**Buffering** 
- Should employ **buffers** to **decouple** one layer from another layer

## Buffering
![[Pasted image 20251124134554.png]]
a) If unbuffered with interrupt-driven I/O, then it will interrupt you tons of times (e.g. printer interrupts once per character)
b) If buffered, then it will only interrupt when buffer is full (e.g. printer interrupts once per n characters)
c) With buffer in kernel space and copy in user space, buffer is always there for the device (in kernel space) so the user space copy can be paged out (if needed)
- We need user space buffer so user can access the buffer without interrupting
- Interrupt handler copies the buffer from kernel to user space.
d) Additional buffer in kernel space allows device to keep writing to buffer while it waits for CPU to acknowledge interrupt to empty initial buffer.

![[Pasted image 20251124134638.png]]
- Things on network need to be transmitted at an equal pace/space

## Error Handling
I/O **software** needs to **handle** 3 types of I/O errors.

**Program Errors** 
- Doing an **impossible operation**
- e.g. attempt to write to an input device

**Parameter Errors**
- Passing invalid parameters
- e.g. invalid buffer address, invalid device number, etc.

**Actual I/O Errors** 
- Errors happen in the actual device.
- e.g. attempt to read from a damaged disk block

# I/O Software Layers
![[io_software_layers.png]]

## User Process I/O Software
User process I/O software is actually the **user space library functions** that perform I/O operations:
- Ex. `scanf()`, `printf()`, etc.

## Device-Independent I/O Software
Functions of the **device-independent** I/O software:
- Uniform interfacing for device drivers
	- ![[io_device_standardization.png]]
- Buffering
	- **Kernel level buffering** is handled by device-independent I/O software
- Error reporting/handling
	- Framework for error handling is **device independent** because many errors are device specific.
	- **Program and Parameter Errors** 
		- Device independent error handling framework reports back an error code to the caller
	- **Actual I/O Errors** 
		- Device drivers or disk controllers mostly handle them. 
		- Device independent error handling framework also handles them when the lower layers don't and the response is specific to the **error type**
- Allocating and releasing dedicated devices
	- **Open and Close**
		- Forces the process to **open** and **close** a **special file** specific to a dedicated device **before** and **after** using it
	- **Device Queue**
		- Device driver I/O software maintains a **queue** for the device.
		- **Requesting process enters** at the **back** of a device queue to **get access to the device**. 
		- Process at the **front** of the queue get access of the device and is **removed** from the queue
- Providing a device-independent **block size**
	- **Hides** the fact that devices (disks) often come with **different block sizes** by providing a **common logical block size.** 
		- Treats **several** device blocks as a **single** logical block. 
	- **Upper layers** deal only with **abstract devices** that all use the **same logical block size,** independent of the physical block size.

Device-independent I/O software is actually the **system call functions** both user space and kernel space versions:
- Ex. `open()`, `close()`, `read()`, `write()`, etc.

# Device Drivers
Device drivers are **code** specific to a **particular device or a class of devices**. 
- Directly **accesses device controller’s registers** for giving commands, reading status, and transferring data. 
- Device **manufacturers supply the code** along with the devices. 
- Device manufacturers follow the **standard interfaces defined by the operating systems** to write device driver codes. 
- **Loaded dynamically** and **executed** as part of operating system code, i.e., **kernel mode**

## Device Driver Functions:
1. Accepts abstract **read** and **write** requests from **device independent layer.** 
2. Returns error if the request parameters are not valid. 
3. **Translates** abstract terms into **concrete terms**
	- e.g., device block into device head, cylinder, sector etc.
4. **Initializes** the device, if needed. 
5. **Reads** device controller **status register** to check whether the device is in use or idle.
6. If the device **in use** enters the request into device queue and **blocks itself.** **Device interrupt awakens** the blocked device driver (when it is taken from front of queue). 
7. **Writes commands** to the device controller’s **control register** and **blocks itself** to let the device take actions and **awakes the driver** by issuing a **device interrupt.** 
8. If successful and if it is necessary, passes the **data** to the **device-independent software**. If unsuccessful, passes the **error code** to the caller.
9. If more requests are pending in the device queue, proceeds with the one at the **front** and repeats steps 8 to 10. 
10. If no more pending requests, blocks itself until a new request arrives.

Logical position of device drivers (between controller and rest of OS):
![[device_driver_pos.png]]
- In reality, all communication between drivers and device controllers goes over the **bus**.

# Interrupt Handlers
- Interrupt hardware **flips the mode bit** in PSW to kernel mode. 
- **Pushes PC** of the current process **onto stack.** 
- **Jumps** to the **interrupt handler routine**

Device manufacturers also make interrupt handlers. 

Interrupt is from hardware - trap is from specific instruction

## Interrupt handler routine (I/O software) steps:
1. **Pushes registers** (including the PSW) of the current process that are not saved by interrupt hardware **onto the stack.** 
2. Determines which **interrupt service routine to invoke based on interrupt vector.** 
3. Sets up **context** for interrupt service routine.
4. Sets up a **stack** for the interrupt service routine. 
5. **Copies saved registers** (saved by the device driver) from the stack into **process table.**
6. Runs **interrupt service routine**, which extracts information from interrupting device controller’s registers and conditionally **unblocks** the corresponding **user process.** 
7. **Acknowledges** interrupt controller. If no interrupt controller, re-enable interrupts. 
	- End of interrupt
8. Gets the **interrupted process to run.** 
	1. Sets up the **MMU context** for the interrupted process to run.
	2. **Loads** the interrupted process’s **PC, PSW, and other necessary registers.** 
	3. Return from interrupt calling **IRET**, as a consequence hardware **flips the mode bit to user mode.** 
	4. Start running the **interrupted process.**